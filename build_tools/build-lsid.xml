<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE project [
    <!ENTITY parseLsidRegexp SYSTEM "parse-lsid-regexp.xml">
]>

<project basedir="." name="gp.build-lsid"
    xmlns:rsel="antlib:org.apache.tools.ant.types.resources.selectors"
    xmlns:rcmp="antlib:org.apache.tools.ant.types.resources.comparators"
    xmlns:props="antlib:org.apache.ant.props"
    xmlns:if="ant:if"
    xmlns:unless="ant:unless"
>
    <!--
      ===================================================================
          Module development workflow notes ...
      ===================================================================
         use-case: new module
             declare baseLsid
             declare initial version
         use-case: existing module
             extract baseLsid
             extract existing version

         workflow
             1) pull latest from GitHub
             2) increment version number
             3) create new release branch
             4) create build snapshot, e.g. 
                 a) increment buildnumber
                 b) create zip file,
                    ${module.name}_v${module.version}-build.${buildnumber}.zip
    -->

    <target name="require-common-module-code">
        <!-- requires project name="gp.build-lsid" -->
        <dirname property="this.dirname" file="${ant.file.gp.build-lsid}" />
        <property name="common.module.code.dir" location="${this.dirname}/../../common_module_code" />
        <log-property name="common.module.code.dir" />
    </target>

    <target name="require-antcontrib" depends="require-common-module-code">
        <taskdef resource="net/sf/antcontrib/antlib.xml">
            <classpath>
                <fileset dir="${common.module.code.dir}/lib" includes="*.jar" />
            </classpath>
        </taskdef>
    </target>

    <!--
      Enable verbose output
          ant -Dverbose=true ...
      As a convenience, also set to true, based on ant command line flags
          ant -v (-verbose) ...
          ant -d (-debug) ...

      Note: Use the 'echoproperties' task for extended debugging, e.g. 
          <echoproperties destfile="echoproperties.out" />
    -->
    <target name="init-verbose">
        <condition property="verbose">
            <or>
                <istrue value="${verbose}" />
                <contains string="${sun.java.command}" substring=" -v " />
                <contains string="${sun.java.command}" substring=" -verbose " />
                <contains string="${sun.java.command}" substring=" -d " />
                <contains string="${sun.java.command}" substring=" -debug " />
            </or>
        </condition>
        <echo if:true="${verbose}" message="verbose='${verbose}'" />
    </target>

    <target name="init" depends="init-verbose">
        <property name="buildnumber.properties.file" location="buildnumber.properties" />
        <property name="dist.dir" value="target" />
        <property name="lsid.test_version" value="999999999" />

        <!-- for testing and development -->
        <property name="demo-baselsid" value="urn:lsid:org.genepattern:module.demo:00002" />
    </target>

    <!--
      ===================================================================
             Module Release Tasks
      ===================================================================
      Package module, create module zip file for installation on a GP server.

          ./dist/{module.name}_v{module.version}.zip

      Requirements:
          module.name
          module.lsid.no_version
          module.lsid.version


      Dependencies ...
          next-module-version
          next-build-id
    -->


    <!--
      ===================================================================
          Package module for release
      ===================================================================
      Create the module.zip file for upload to a GP server or a module
      repository.
    -->
    <target name="mk-dist-dir" depends="init">
        <mkdir dir="${dist.dir}" />
    </target>

    <target name="load-manifest" depends="init, require-parse-lsid"
        description="Load 'manifest.*' properties from the manifest file"
    >
        <property file="manifest" prefix="manifest" />
        <parse-lsid lsid="${manifest.LSID}" prefix="manifest" />
    </target>

    <target name="increment-buildnumber" depends="init"
        description="Increment the build.number, creates a buildnumber.properties file if needed"
    >
        <fail-if-not-set prop="buildnumber.properties.file" />
        <buildnumber file="${buildnumber.properties.file}" />
        <property name="build.metadata" value="+build.${build.number}" />
    </target>

    <target name="reset-buildnumber">
        <delete file="${buildnumber.properties.file}" />
    </target>

    <target name="load-buildnumber" depends="init"
        description="Load 'build.number' from the buildnumber.properties file"
    >
        <property file="${buildnumber.properties.file}" />
        <!-- property name="build.number" value="" / -->
        <log-property name="buildnumber.properties.file" />
        <log-property name="build.number" />
    </target>

    <target name="init-zip-filename" 
        depends="load-manifest, load-buildnumber" 
    >
        <fail-if-not-set prop="manifest.name" />

        <!--
            semver.build.metadata
            semver.pre-release.version
        -->
        <property name="build.metadata.label" value="" />
        <condition property="pre-release.label" value="-local.${build.number}" else="">
            <isset property="build.number" />
        </condition>
        <property name="zip.filename" 
            value="${manifest.name}_v${manifest.lsid.version}${pre-release.label}${build.metadata.label}.zip" />
        <log-property name="zip.filename" />
    </target>

    <target name="init-module-files" depends="init"
        description="initialize the 'module.excludes' patternset"
    >
        <!--
            Files to be ignored aka excluded from the module.zip file. Declared as an ant patternset.
                See: https://ant.apache.org/manual/Types/patternset.html
            Works best with Ant 1.8.2+, which adds 'defaultexcludes' for git and others.
                See: https://ant.apache.org/manual/dirtasks.html
        -->
        <patternset id="module.excludes.default">
            <exclude name="archive/**" />
            <exclude name="${buildnumber.properties.file}" /> 
            <exclude name="build.xml*" />
            <exclude name="gpunit/**" />
            <exclude name="prerelease.version" /> 
            <exclude name="release.version" />
            <exclude name="${dist.dir}/**" />
            <exclude name="temp/**" />
            <exclude name="tmp/**" />
            <exclude name="to_del/**" />
        </patternset>

        <!-- 
          Additional files to be excluded from the module.zip file. Declared as 
          a comma- or space- separated list of values.
        -->
        <property name="module.excludes.extra" value="
            test_excludes/**"
        />

        <patternset id="module.excludes" excludes="${module.excludes.extra}">
            <patternset refid="module.excludes.default" />
        </patternset>

        <!--
          ===================================================================
              Preserve exec flags
          ===================================================================
            Preserve execute permission mode (chmod 755) when adding binary
            files to the the module.zip file.

            To add executable files to the module.zip file ...
            Declare an 'exec-files' property whose value is a comma- or space-
            separated list of file patterns. For example,

                <property name="exec-files" value="bin/myapp" />

            By default,
                <property name="exec-files" value="" />
            no exec flags are preserved.
        -->
        <condition property="has.exec-files" value="true">
            <and>
                <isset property="exec-files" />
                <length string="${exec-files}" when="greater" length="0" />
            </and>
        </condition>
    </target>

    <target name="package-module" depends="init, init-module-files, init-zip-filename, mk-dist-dir"
        description="Create the module ${zip.filename}"
    >
        <!--
            Create the module.zip file.

            Optionally, set the exec flag (filemode=755) for each item in the 
            'exec-files' list.
        -->
        <!-- fail if dist.dir does not exist -->
        <fail message="Missing required directory, dist.dir='${dist.dir}'">
            <condition><not><available file="${dist.dir}" type="dir"/></not></condition>
        </fail>

        <patternset id="module.files" excludes="${exec-files}" >
            <patternset refid="module.excludes" />
        </patternset>
        <patternset id="module.files.exec" includes="${exec-files}" >
            <patternset refid="module.excludes" />
        </patternset>

        <fail-if-not-set prop="zip.filename" />

        <zip destfile="${dist.dir}/${zip.filename}" whenempty="fail" defaultexcludes="true">
            <zipfileset dir="${basedir}" filemode="644">
                <patternset refid="module.files" />
            </zipfileset>

            <zipfileset dir="${basedir}" filemode="755" if:true="${has.exec-files}" >
                <patternset refid="module.files.exec" />
            </zipfileset>
        </zip>
    </target>

    <!--
      ===================================================================
          Semantic Versioning Notes
      ===================================================================
      Semantic Versioning (see: http://semver.org)
          Major.Minor.Patch-PrereleaseVersion+BuildMetaData

      sem.version=${manifest.lsid.version}\
          ${prerelease.version}\
          ${build.metadata}

      prerelease.version=[-local.prerelease]
      build.metadata=[+local.buildnum]

         -Dversion=<fixed> | 

         see: bower, $ bower version [<newversion> | major | minor | patch]
Run this in a package directory to bump the version and write the new data back to the bower.json file.

The newversion argument should be a valid semver string, or a valid second argument to semver.inc (one of “build”, “patch”, “minor”, or “major”). In the second case, the existing version will be incremented by 1 in the specified field.

If run in a git repo, it will also create a version commit and tag, and fail if the repo is not clean.

    -->

    <target name="increment-version" depends="init-next-module-version, prompt-version.comment"
        description="set the lsid version and add a version comment to the manifest file"
    >
        <fail-if-not-set prop="next.version" />
        <fail-if-not-set prop="next.version.comment" />
        <condition property="lsid.version.changed">
            <not><equals arg1="${manifest.lsid.version}" arg2="${next.version}" /></not>
        </condition>
        <!-- example: fail the build if the version didn't change
         fail unless="lsid.version.changed" 
            message="lsid.version did not change, not changing version comment without a new lsid.version" 
         /
        -->
        <propertyfile file="manifest">
            <entry key="version" type="string" value="${next.version.comment}" />
            <entry key="LSID" type="string" value="${manifest.lsid.no_version}:${next.version}" />
        </propertyfile>

        <antcall target="reset-buildnumber" if:true="${lsid.version.changed}" />
    </target>


    <target name="set-base-lsid" depends="prompt-increment, load-manifest, init-next-module-version"
        description="set the base lsid (aka 'lsid.no_version') in the manifest file"
    >

        <input message="Set the base lsid in the manifest file, -Dnext.lsid.no_version=" addproperty="next.lsid.no_version"
        />
        <log-property name="next.lsid.no_version" />
        <fail-if-not-set prop="next.lsid.no_version" />

        <fail-if-not-set prop="next.version" />
        <property name="next.version.comment" value="Changing base lsid to '${next.lsid.no_version}'" />
        <fail-if-not-set prop="next.version.comment" />

        <propertyfile file="manifest">
            <entry key="version" type="string" value="${next.version.comment}" />
            <entry key="LSID" type="string" value="${next.lsid.no_version}:${next.version}" />
        </propertyfile>
    </target>

    <target name="set-version-comment" depends="load-manifest, prompt-version.comment"
        description="set version comment in the manifest file"
    >
        <fail-if-not-set prop="next.version.comment" />
        <propertyfile file="manifest">
            <entry key="version" type="string" value="${next.version.comment}" />
        </propertyfile>
    </target>

    <!-- Prompt for the version 'increment' flag -->
    <target name="prompt-increment" depends="init">
        <input message="Set -Dincrement=" addproperty="increment"
            validargs="next,major,minor,patch,fixed,none"
            defaultvalue="next"
        />
        <log-property name="increment" />
    </target>

    <target name="prompt-version.comment" depends="init">
        <input message="" addproperty="next.version.comment" />
        <log-property name="next.version.comment" />
    </target>

    <!-- 
      Set the 'next.version' property from the LSID in the manifest,
      based on the 'increment' flag:
          next | major | minor | patch | fixed (aka 999999) | none
    -->
    <target name="init-next-module-version" 
        depends="prompt-increment, load-manifest"
        description="Set the 'next.version' from the current LSID version"
    >
        <property name="increment" value="none" />
        <set-next-version increment="${increment}" />
        <log-property name="next.version" />
    </target>

    <target name="show-lsid-from-manifest" depends="load-manifest"
        description="Show lsid version from the manifest file"
    >
        <echo>manifest.LSID=${manifest.LSID}</echo>
        <echo>manifest.lsid.no_version=${manifest.lsid.no_version}</echo>
        <echo>manifest.lsid.version=${manifest.lsid.version}</echo>
    </target>

    <target name="show-version" depends="load-manifest, load-buildnumber"
        description="Show current lsid and version comment from the manifest file"
    >
        <echo>${manifest.lsid.no_version}</echo>
        <echo     if:set="build.number">v${manifest.lsid.version} (build: ${build.number})</echo>
        <echo unless:set="build.number">v${manifest.lsid.version}</echo>
        <echo>${manifest.version}</echo>
    </target>

    <target name="show-next-version" depends="load-manifest, load-buildnumber, prompt-increment"
        description="Show the next lsid version"
    >
        <echo>next:       ${manifest.lsid.increment.next}</echo>
        <echo>next_major: ${manifest.lsid.increment.major}</echo>
        <echo>next_minor: ${manifest.lsid.increment.minor}</echo>
        <echo>next_patch: ${manifest.lsid.increment.patch}</echo>
        <echo>test:       ${manifest.lsid.increment.fixed}</echo>
        <echo>none:       ${manifest.lsid.increment.none}</echo>

        <condition property="next_version" value="manifest.lsid.increment.${increment}" else="manifest.lsid.increment.none">
            <isset property="increment" />
        </condition>
        <echo-property name="${next_version}" />
    </target>



    <!--
      ===================================================================
          LSID
      ===================================================================
      Template:
          urn:lsid:{authority}:{namespace}:{id}:{version}

      Example, ConvertLineEndings
          urn:lsid:broad.mit.edu:cancer.software.genepattern.module.analysis:00002:1
          
          authority  => broad.mit.edu
          namespace  => cancer.software.genepattern.module.analysis
          id         => 00002
          version    => 1
    -->

    <!--
      ===================================================================
          parse-lsid macrodef
      ===================================================================
      Usage:
          <parse-lsid 
              lsid=${lsid}, with or without the trailing version number
              prefix=${prefix},  optional, to append to the ant property name
              verbose=true|false, optional default="false", for verbose output
          /> 

      Result: Sets the following ant properties
          ${prefix}.lsid.authority
          ${prefix}.lsid.namespace
          ${prefix}.lsid.identifier
          ${prefix}.lsid.version
          ${prefix}.lsid.no_version, the full lsid minus the version
          ${prefix}.lsid.version.major, the current major version from the manifest
          ${prefix}.lsid.version.minor, the current minor version from the manifest
          ${prefix}.lsid.version.patch, the current patch version from the manifest

      Sets additional properties for incrementing the version number.
          ${prefix}.lsid.next_version, the next version, based on the current patch-level
          ${prefix}.lsid.next_major,   the next major version, e.g. 1->2; 1.2->2 
          ${prefix}.lsid.next_minor,   the next minor version, e.g. 1->1.1; 1.2->1.3; 1.2.1->1.3
          ${prefix}.lsid.next_patch,   the next patch version, e.g. 1->1.0.1; 1.2->1.2.1; 1.2.1->1.2.2

      Example:
           <parse-lsid lsid="urn:lsid:org.genepattern:module.demo:00002:0.1" prefix="test" />
           test.lsid.authority  = org.genepattern
           test.lsid.namespace  = module.my_module
           test.lsid.identifier = 00002
           test.lsid.version    = 0.1
           test.lsid.no_version = urn:lsid:org.genepattern:module.my_module:00002
 -->
    <target name="require-parse-lsid" depends="define-parse-lsid" />
    <target name="define-parse-lsid" depends="require-antcontrib">
        <!-- define macrodef in a target to include antcontrib as a dependency -->
        <macrodef name="parse-lsid"
            description="Set lsid properties of the form '@{prefix}.lsid.[authority | namespace | identifier | version | no_version]'"
        >
            <attribute name="lsid" description="the lsid" />
            <attribute name="prefix" default="" 
                description="prefix to prepend to the lsid.* property names; similar to the 'prefix' attribute of the property task" 
            />
            <attribute name="verbose" default="${verbose}" />

            <sequential>
                <echo if:true="@{verbose}">parse-lsid, lsid=@{lsid}</echo>

                <local name="_lsid_in" />
                <property name="_lsid_in" value="@{lsid}" />

                <!-- if necessary, append '.' to prefix -->
                <local name="prefix" />
                <condition property="prefix" value="@{prefix}." else="@{prefix}" >
                    <length string="@{prefix}" when="greater" length="0" />
                </condition>

                <script language="javascript" setbeans="false"> <![CDATA[
                    var lsid_tokens = project.getProperty('_lsid_in').split(':');
                    prefix = project.getProperty('prefix');
                    lsid_version='';
                    if (lsid_tokens.length > 2) {
                        project.setProperty(prefix+'lsid.authority',  lsid_tokens[2]);
                    }
                    if (lsid_tokens.length > 3) {
                        project.setProperty(prefix+'lsid.namespace',  lsid_tokens[3]);
                    }
                    if (lsid_tokens.length > 4) {
                        project.setProperty(prefix+'lsid.identifier', lsid_tokens[4]);
                        project.setProperty(prefix+'lsid.no_version', lsid_tokens.slice(0,5).join(':'));
                    }
                    if (lsid_tokens.length > 5) {
                        lsid_version=lsid_tokens[5];
                    }
                    project.setProperty(prefix+'lsid.version',         lsid_version);
                    project.setProperty(prefix+'lsid.increment.none',  lsid_version);
                    project.setProperty(prefix+'lsid.increment.fixed', '999999999');
                ]]> </script>

                <local name="version" />
                <condition property="version" value="${@{prefix}.lsid.version}" else="${@{prefix}lsid.version}" >
                    <length string="@{prefix}" when="greater" length="0" />
                </condition>
                <echo if:true="@{verbose}">local version=${version}</echo>

                <parse-lsid-version prefix="@{prefix}" version="${version}" type="lsid" failonerror="true" />

                <script language="javascript" setbeans="false"> <![CDATA[
                    prefix = project.getProperty('prefix');

                    var X = Number( project.getProperty(prefix+'lsid.version.major') );
                    var Y = Number( project.getProperty(prefix+'lsid.version.minor') );
                    var Z = Number( project.getProperty(prefix+'lsid.version.patch') );

                    // major, X
                    var nextMajor = "" + (X+1);
                    var nextMinor = "" + X + ".1";
                    var nextPatch = "" + X + "." + "0" + "." + "1";
                    var nextVersion = nextMajor;

                    // minor, X.Y 
                    if (Y) {
                        nextMinor = "" + X + "." + (Y+1);
                        nextPatch = "" + X + "." + Y + ".1";
                        nextVersion = nextMinor;
                    }

                    // patch, X.Y.Z
                    if (Z) {
                        nextPatch = "" + X + "." + Y + "." + (Z+1);
                        nextVersion = nextPatch;
                    }

                    project.setProperty(prefix+'lsid.increment.next',  nextVersion);
                    project.setProperty(prefix+'lsid.increment.major', nextMajor);
                    project.setProperty(prefix+'lsid.increment.minor', nextMinor);
                    project.setProperty(prefix+'lsid.increment.patch', nextPatch);

                ]]> </script>
                <echo-lsid prefix="@{prefix}" if:true="@{verbose}" />
            </sequential>
        </macrodef>

        <macrodef name="parse-lsid-version">
            <attribute name="version" description="the lsid version string" />
            <attribute name="prefix" default="" 
                description="prefix to prepend to the lsid.* property names; similar to 'prefix' attribute of the property task" 
            />
            <attribute name="type" default="strict" 
                description="one of 'strict', 'lsid', 'semver', semver accepts optional -prerelease and +build tags" />
            <!-- attribute name="verbose" default="false" / -->
            <attribute name="failonerror" default="true" />
            <attribute name="ignoreempty" default="true" />

            <sequential>
                <!-- if necessary, append '.' to prefix -->
                <local name="prefix" />
                <condition property="prefix" value="@{prefix}." else="@{prefix}" >
                    <length string="@{prefix}" when="greater" length="0" />
                </condition>

                <!-- ignore lsid.no_version -->
                <fail message="lsid.version not set">
                    <condition>
                        <and>
                            <equals arg1="@{failonerror}" arg2="true" />
                            <not><equals arg1="@{ignoreempty}" arg2="true" /></not>
                            <not><equals arg1="@{version}" arg2="" /></not>
                        </and>
                    </condition>
                </fail>

                <local name="lsid.version.regex" />
                <property name="lsid.version.regex" 
                    value="^([0-9]+)(\.([0-9]+))?(\.([0-9]+))?(-[^+]+)?(\+.*)?$"
                /> 

                <propertyregex property="${prefix}lsid.version.regex_selection" 
                    input="@{version}" regexp="${lsid.version.regex}"
                    select="1='\1', 2='\2', 3='\3', 4='\4', 5='\5', 6='\6', 7='\7', 8='\8'"
                />
                <echo-property if:true="@{verbose}" 
                    prefix="${prefix}" name="lsid.version.regex_selection" pad="     " />

                <!--
                  Error handling
                  Throw exception when ...
                      a) type is strict aka lsid and prerelease and build are set
                -->
                <fail message="Invalid lsid.version='@{version}'">
                    <condition>
                        <and>
                            <equals arg1="@{failonerror}" arg2="true" />
                            <not><isset property="lsid.version.regex_selection" /></not>
                            <!-- short-circuit: emtpy version, must be non-empty or !ignoreempty -->
                            <and>
                                <not><equals arg1="@{ignoreempty}" arg2="true" /></not>
                                <equals arg1="@{version}" arg2="" />
                            </and>
                        </and>
                    </condition>
                </fail>

                <propertyregex property="${prefix}lsid.version.major" select="\1"
                    input="@{version}" regexp="${lsid.version.regex}" />
                <propertyregex property="${prefix}lsid.version.minor" select="\3"
                    input="@{version}" regexp="${lsid.version.regex}" />
                <propertyregex property="${prefix}lsid.version.patch" select="\5"
                    input="@{version}" regexp="${lsid.version.regex}" />
                <propertyregex property="${prefix}lsid.version.prerelease" select="\6"
                    input="@{version}" regexp="${lsid.version.regex}" />
                <propertyregex property="${prefix}lsid.version.build" select="\7"
                    input="@{version}" regexp="${lsid.version.regex}" />

                <fail message="Invalid lsid.version='@{version}', Set type='semver' to allow 'prerelease' and or 'build metadata'">
                    <condition>
                        <and>
                            <equals arg1="@{failonerror}" arg2="true" />
                            <not><equals arg1="@{type}" arg2="semver" /></not>
                            <or>
                                <not><equals arg1="${@{prefix}prerelease}" arg2="" /></not>
                                <not><equals arg1="${@{prefix}build}" arg2="" /></not>
                            </or>
                            <!-- short-circuit: emtpy version, must be non-empty or !ignoreempty -->
                            <and>
                                <not><equals arg1="@{ignoreempty}" arg2="true" /></not>
                                <equals arg1="@{version}" arg2="" />
                            </and>
                        </and>
                    </condition>
                </fail>
            </sequential>
        </macrodef>

        <macrodef name="set-next-version">
            <attribute name="lsid-prefix" default="manifest" 
                description="in support of variable lsid properties, e.g. getProperty( ${@{lsid-prefix}.lsid.next_version )" 
            />
            <attribute name="name" default="next.version" 
                description="the name of the property to set, e.g. 'next.version'"
            />
            <attribute name="increment" default="none" />
            <sequential>
                <local name="prefix" />
                <condition property="prefix" value="@{lsid-prefix}." else="@{lsid-prefix}" >
                    <length string="@{lsid-prefix}" when="greater" length="0" />
                </condition>

                <local name="increment_prop" />
                <condition property="increment_prop" value="${prefix}lsid.increment.@{increment}" else="${prefix}lsid.increment.none">
                    <length string="@{increment}" when="greater" length="0" />
                </condition>
                <set-property-from name="@{name}" from="${increment_prop}" />
                <fail-if-not-set prop="${increment_prop}" />
                <log-property name="@{name}" />
            </sequential>
        </macrodef>
    </target>

    <target name="test-set-next-version" depends="define-parse-lsid, load-manifest, prompt-increment"
        description="for testing the 'set-next-version' macrodef"
    >
        <set-next-version increment="${increment}" />
        <echo-property name="increment" />
        <echo-property name="next.version" />
    </target>

    <!--
      set-property-from macrodef

          Set a property from an existing property, similar to antcontrib propertycopy,
      with additional 'name-prefix' and 'from-prefix' attributes.

          The optional 'name-prefix' modifies the name of the property to set.
          The optional 'from-prefix' modifies the name of the property to get.

      E.g.
          <property name=${[${name-prefix}.]name} value=${[${from-prefix}.]from} />
    -->
    <macrodef name="set-property-from">
        <attribute name="name-prefix" default="" />
        <attribute name="name" />
        <attribute name="from-prefix" default="" />
        <attribute name="from" />
        <sequential>
            <!-- if necessary, append '@{name-prefix}.' to @{name} -->
            <local name="name" />
            <condition property="name" value="@{name-prefix}.@{name}" else="@{name}" >
                <length string="@{name-prefix}" when="greater" length="0" />
            </condition>
            <condition property="${name}" value="${@{from-prefix}.@{from}}" else="${@{from}}" >
                <length string="@{from-prefix}" when="greater" length="0" />
            </condition>
        </sequential>
    </macrodef>

    <macrodef name="log-property">
        <attribute name="prefix" default="" />
        <attribute name="name" />
        <attribute name="pad" default="" />
        <sequential>
            <echo-property if:true="${verbose}" 
                prefix="@{prefix}" name="@{name}" pad="@{pad}" />
        </sequential>
    </macrodef>

    <macrodef name="fail-if-not-set">
        <attribute name="prop" />
        <attribute name="check-empty" default="true" />
        <sequential>
            <fail message="Missing required property, '@{prop}' not set" unless:set="@{prop}" />
            <fail message="Missing required property, '@{prop}' is empty">
                <condition>
                    <and>
                        <equals arg1="@{check-empty}" arg2="true" />
                        <equals arg1="${@{prop}}" arg2="" />
                    </and>
                </condition>
            </fail>
        </sequential>
    </macrodef>

    <!--
      The 'echo-property' macrodef is a workaround to handle variable property names.
      This won't work in a target:
           <echo>${${prefix}lsid.authority}</echo>
      This alternative will work inside a macrodef:
           <echo>${@{prefix}lsid.authority}</echo>
    -->
    <macrodef name="echo-property">
        <attribute name="prefix" default="" 
            description="the prefix to append to the property name, do not add trailing '.'" />
        <attribute name="name" />
        <attribute name="pad" default="" 
            description="for formatting"/>
        <attribute name="empty-val" default="" 
            description="what to display when the value is not set" />
        <sequential>
            <local name="name.set" />
            <condition property="name.set" else="false">
                <isset property="@{prefix}@{name}" />
            </condition>

            <echo     if:true="${name.set}">  @{prefix}@{name} @{pad} => ${@{prefix}@{name}}</echo>
            <echo unless:true="${name.set}">  @{prefix}@{name} @{pad} => @{empty-val} </echo>
        </sequential>
    </macrodef>

    <macrodef name="echo-lsid">
        <attribute name="prefix" default="" />
        <attribute name="show-version-details" default="true" />
        <sequential>
            <!-- if necessary, append '.' to prefix -->
            <local name="prefix" />
            <condition property="prefix" value="@{prefix}." else="@{prefix}" >
                <length string="@{prefix}" when="greater" length="0" />
            </condition>
            <echo-property prefix="${prefix}" name="lsid.authority" pad="    " />
            <echo-property prefix="${prefix}" name="lsid.namespace" pad="    " />
            <echo-property prefix="${prefix}" name="lsid.identifier" pad="   " />
            <echo-property prefix="${prefix}" name="lsid.no_version" pad="   " />
            <echo-property prefix="${prefix}" name="lsid.version" pad="      " />
            <echo-lsid-version      if:true="@{show-version-details}" prefix="${prefix}" />
            <echo-lsid-next-version if:true="@{show-version-details}" prefix="${prefix}"  />
        </sequential>
    </macrodef>

    <macrodef name="echo-lsid-version">
        <attribute name="prefix" default="" />
        <sequential>
            <echo-property prefix="@{prefix}" name="lsid.version.major" pad="" />
            <echo-property prefix="@{prefix}" name="lsid.version.minor" pad="" />
            <echo-property prefix="@{prefix}" name="lsid.version.patch" pad="" />
        </sequential>
    </macrodef>

    <macrodef name="echo-lsid-next-version">
        <attribute name="prefix" default="" />
        <sequential>
            <echo-property prefix="@{prefix}" name="lsid.increment.next" pad="    " />
            <echo-property prefix="@{prefix}" name="lsid.increment.major" pad="   " />
            <echo-property prefix="@{prefix}" name="lsid.increment.minor" pad="   " />
            <echo-property prefix="@{prefix}" name="lsid.increment.patch" pad="   " />
            <echo-property prefix="@{prefix}" name="lsid.increment.fixed" pad="   " />
            <echo-property prefix="@{prefix}" name="lsid.increment.none" pad="    " />
        </sequential>
    </macrodef>

    <target name="test-parse-lsid-version" depends="require-parse-lsid"
        description="test the 'parse-lsid-version' macrodef"
    >
        <input message="Enter lsid.version: " addproperty="lsid.version"
            defaultvalue="3.14.159" 
        />
        <input message="Enter prefix: " addproperty="prefix" />
        <parse-lsid-version version="${lsid.version}" prefix="${prefix}" type="strict" />
        <echo-lsid-version prefix="${prefix}" />
    </target>

    <target name="test-parse-lsid" depends="init, require-parse-lsid"
        description="test the 'parse-lsid' macrodef, single run"
    >
        <input message="Enter lsid.version: " addproperty="lsid.version"
            defaultvalue="3.14.159" 
        />
        <input message="Enter prefix: " addproperty="prefix" />
        <fail-if-not-set prop="demo-baselsid" />
        <parse-lsid lsid="${demo-baselsid}:${lsid.version}"  prefix="${prefix}" />
        <echo-lsid prefix="${prefix}" />
    </target>

    <target name="test-parse-lsid-suite" depends="init, require-parse-lsid"
        description="for testing the parse-lsid macrodef, built-in suite"
    >
        <fail-if-not-set prop="demo-baselsid" />
        <parse-lsid lsid="${demo-baselsid}"       prefix="test.01" verbose="true" />
        <parse-lsid lsid="${demo-baselsid}:1"     prefix="test.02" verbose="true" />
        <parse-lsid lsid="${demo-baselsid}:0.1"   prefix="test.03" verbose="true" />
        <parse-lsid lsid="${demo-baselsid}:0.0.1" prefix="test.04" verbose="true" />

        <parse-lsid lsid="${demo-baselsid}:2"     prefix="test.05" verbose="true" />
        <parse-lsid lsid="${demo-baselsid}:2.1"   prefix="test.06" verbose="true" />
        <parse-lsid lsid="${demo-baselsid}:2.0.1" prefix="test.07" verbose="true" />

        <parse-lsid lsid="${demo-baselsid}:4.8.33" prefix="test.08" verbose="true" />

        <!-- invalid lsid ... -->
        <parse-lsid lsid="${demo-baselsid}:v1" prefix="test.09" verbose="true" />
        <parse-lsid lsid="${demo-baselsid}:v1.2" prefix="test.10" verbose="true" />
        <parse-lsid lsid="${demo-baselsid}:v1.2.5" prefix="test.11" verbose="true" />

    </target>

&parseLsidRegexp;

    <target name="nextMinorVersion" depends="require-antcontrib"
        description="Increment minor version"
    >
        <property name="header" value="##Generated file - do not modify!" />
        <propertyfile file="version.properties" comment="${header}">
            <entry key="product.build.major"   type="int"  value="=" />
            <entry key="product.build.minor"   type="int"  operation="+" value="1" />
            <entry key="product.build.patch"   type="int"  value="0" />
            <entry key="product.build.date"    type="date" value="now" />
        </propertyfile>
    </target>

    <!--
      ===================================================================
          (Legacy) Lsid Version management
      ===================================================================
         Using 'release.version' and 'prerelease.version' files.

         Example 'release.version' file: 
             # update release version number
             build.number=4

         Example 'prerelease.version' file: 
             # prerelease version number
             prerelease.number=1
    -->

    <!-- 
      target: load-release-version
          deprecated, this is here for illustration purposes 

      description=
          Set 'release.build.number' and 'release.prerelease.number' 
          from the release.version and prerelease.version files"
    -->
    <target name="load-release-version">
        <property file="release.version" prefix="release" />
        <property file="prerelease.version" prefix="release" />
        <log-property name="release.build.number" pad="     "/>
        <log-property name="release.prerelease.number" pad="" />
    </target>

    <target name="init-lsid-legacy" depends="require-antcontrib"
        description="Set lsid properties from 'module.lsid.registry', 'release.version', and 'prerelease.version' files"
    >
        <property name="lsid.registry.name" location="${common.module.code.dir}/module.lsid.registry" />
        <property file="${lsid.registry.name}" /> 
        <property name="LSID.key" value="${ant.project.name}.lsid" />
        <propertycopy name="LSID.noVersion" from="${LSID.key}" />
        <echo>$${LSID.key} = ${LSID.key}</echo>
        <echo>$${LSID.noVersion} = ${LSID.noVersion}</echo>
    </target>

    <target name="require-lsid-registry-name" depends="require-common-module-code">
        <property name="lsid.registry.name" location="${common.module.code.dir}/module.lsid.registry" />
        <property file="${lsid.registry.name}" /> 
    </target>

    <!--
        copied from commontargets.xml, with explicit dependencies
    -->
    <target name="getLSID" depends="init, require-antcontrib, require-lsid-registry-name">
        <property file="${lsid.registry.name}" />
        <property name="LSID.key" value="${ant.project.name}.lsid" />
        <propertycopy name="LSID.noVersion" from="${LSID.key}" />
        <condition value="${LSID.noVersion}:${version}" property="LSID" else="${LSID.noVersion}:${lsid.test_version}">
            <isset property="version" />
        </condition>
        <echo>${LSID.key} = ${LSID}</echo>
      </target>

    <!--
      ===================================================================
          Clean distribution files
      ===================================================================
    -->
    <target name="clean-dist" depends="init"
        description="clean distribution files"
    >
        <delete dir="${dist.dir}" />
    </target>

</project>
